<!DOCTYPE html>
<html lang="en">
<head>
<title>Lego Hyrule</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body>
<a href="https://threejs.org/">three.js</a> | <a href="https://ldraw.org/">LDraw.org</a>
<script type="importmap">
    {
        "imports": {
            "three":         "/three/v0.180.0/build/three.module.js",
            "three/addons/": "/three/v0.180.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    "use strict";

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { LDrawLoader } from 'three/addons/loaders/LDrawLoader.js';
    import { LDrawConditionalLineMaterial } from 'three/addons/materials/LDrawConditionalLineMaterial.js';
    import { mergeGeometries } from 'three/addons/utils/BufferGeometryUtils.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
    import * as HyruleBuilder from "./HyruleBuilder.js";
    import * as PieceUtils from "./PieceUtils.js";

    /** Read URL parameter options. */
    class Options {
        constructor() {
            const urlParams = new URLSearchParams(window.location.search);

            const setValue = (key, defaultValue, valueValidator, valueParser) => {
                const urlValue = urlParams.get(key);
                if (urlValue === null) {
                    this[key] = defaultValue;
                } else {
                    const parsedValue = valueParser(urlValue);
                    if (Number.isNaN(parsedValue)) {
                        console.log(`'${key}=${urlValue}' is NaN; using default ${defaultValue}`);
                        this[key] = defaultValue;
                    } else {
                        if (valueValidator == null || valueValidator(parsedValue)) {
                            console.log(`Setting url option '${key}=${parsedValue}'`);
                            this[key] = parsedValue;
                        } else {
                            console.log(`'${key}=${urlValue}' is not valid; using default ${defaultValue}`);
                            this[key] = defaultValue;
                        }
                    }
                }
            }

            const setString = (key, defaultValue, valueValidator) =>
                setValue(key, defaultValue, valueValidator, value => value);

            const setBool = (key, defaultValue, valueValidator) =>
                setValue(key, defaultValue, valueValidator, value => "true" === value);

            const setInt = (key, defaultValue, valueValidator) =>
                setValue(key, defaultValue, valueValidator, parseInt);

            const setFloat = (key, defaultValue, valueValidator) =>
                setValue(key, defaultValue, valueValidator, parseFloat);

            setBool("showGui", true);
            setString("upAxis", "Y");
            setBool("showElevation", true);
            setBool("showSamples", false);
            setInt("gapSize", 2);
            setBool("drawLines", true);
            setBool("antialias", true);
            setInt("clearColor", 0xD4EDFC);
            setString("palette", "nes", value => ["nes", "ldraw"].includes(value));
            setFloat("roughness", 1.0);
            setFloat("polygonOffsetFactor", 0.0);

            setFloat("cameraFov", 45.0);
            setFloat("cameraPositionX", -1.0);
            setFloat("cameraPositionY", 3200.0);
            setFloat("cameraPositionZ", 2000.0);
            setFloat("cameraTargetX", 0.0);
            setFloat("cameraTargetY", 0.0);
            setFloat("cameraTargetZ", 0.0);
        }
    };
    const options = new Options();

    function viewWidth () {
        return window.innerWidth - 20;
    }

    function viewHeight() {
        return window.innerHeight - 40;
    }

    const renderer = new THREE.WebGLRenderer({antialias: options.antialias});
    const camera = new THREE.PerspectiveCamera(options.cameraFov, viewWidth() / viewHeight(), 1, 10000);
    const controls = new OrbitControls(camera, renderer.domElement);
    const scene = new THREE.Scene();

    camera.position.set(options.cameraPositionX, options.cameraPositionY, options.cameraPositionZ);
    controls.target.set(options.cameraTargetX, options.cameraTargetY, options.cameraTargetZ);
    renderer.setClearColor(options.clearColor);
    renderer.setSize(viewWidth(), viewHeight());
    renderer.setAnimationLoop(function() {
        controls.update();
        renderer.render(scene, camera);
    });

    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', function() {
        renderer.setSize(viewWidth(), viewHeight());
        camera.aspect = viewWidth() / viewHeight();
        camera.updateProjectionMatrix();
    });

    // Lights.

    [
        {x:  60, y:  150, z:  80, intensity: 3},
        {x: -70, y: -120, z: -50, intensity: 3}
    ].forEach(lightConfig => {
        const light = new THREE.DirectionalLight(0xffffff, lightConfig["intensity"]);
        light.position.set(lightConfig["x"], lightConfig["y"], lightConfig["z"]);
        scene.add(light);
    });

    // LDraw.

    const lDrawLoader = new LDrawLoader();
    lDrawLoader.setConditionalLineMaterial(LDrawConditionalLineMaterial);
    lDrawLoader.setPartsLibraryPath('/ldraw/');
    await lDrawLoader.preloadMaterials('/ldraw/LDConfig.ldr');

    const pieceInstances = new PieceUtils.PieceInstances();

    // Add pieces.

    function addPieces() {

        const pieces = HyruleBuilder.getPieces(options.showElevation, options.showSamples, options.gapSize);
        const loadPendingPartNumbers = new Set(Object.keys(pieces));
        const meshMaterials = {};
        const colors = {};

        // For each piece load the ldraw model and create an instanced mesh of all positions.
        for (const [partNumber, pieceConfigurationsByOpacity] of Object.entries(pieces)) {
            const partFile = `/ldraw/parts/${partNumber}.dat`;
            lDrawLoader.load(
                partFile,
                function(model) {
                    for (const [opacity, pieceConfigurations] of Object.entries(pieceConfigurationsByOpacity)) {
                        meshMaterials[opacity] ??= new THREE.MeshStandardMaterial({
                            roughness: options.roughness,
                            polygonOffsetFactor: options.polygonOffsetFactor,
                            polygonOffset: options.polygonOffsetFactor !== 0.0,
                            opacity: opacity,
                            transparent: opacity !== "1",
                            premultipliedAlpha: opacity !== "1",
                        });

                        const pieceInstancedMeshes = [];
                        const pieceLineInstances = [];
                        model.traverse(item => {
                            if (item.isMesh) {
                                pieceInstancedMeshes.push(new THREE.InstancedMesh(
                                    item.geometry, meshMaterials[opacity], pieceConfigurations.length));
                            } else if (options.drawLines && item.isLineSegments && ! item.isConditionalLine) {
                                pieceLineInstances.push(
                                    {geometry: item.geometry, material: item.material, instances: []});
                            }
                        });

                        const object3d = new THREE.Object3D();
                        for (const [pieceIndex, pieceConfiguration] of pieceConfigurations.entries()) {
                            object3d.position.x = pieceConfiguration.positionX;
                            object3d.position.y = pieceConfiguration.positionY;
                            object3d.position.z = pieceConfiguration.positionZ;
                            object3d.rotation.x = pieceConfiguration.rotationX;
                            object3d.rotation.y = pieceConfiguration.rotationY;
                            object3d.rotation.z = pieceConfiguration.rotationZ;
                            object3d.scale.x    = pieceConfiguration.scaleX;
                            object3d.scale.y    = pieceConfiguration.scaleY;
                            object3d.scale.z    = pieceConfiguration.scaleZ;
                            object3d.updateMatrix();

                            pieceInstancedMeshes.forEach(pieceInstancedMesh => {
                                pieceInstancedMesh.setMatrixAt(pieceIndex, object3d.matrix);
                                const paletteColor = pieceConfiguration.color[options.palette].colorInt;
                                const color = colors[paletteColor] ??= new THREE.Color(paletteColor);
                                pieceInstancedMesh.setColorAt(pieceIndex, color);

                                pieceInstances.add(pieceConfiguration, pieceInstancedMesh, pieceIndex);
                            });
                            pieceLineInstances.forEach(pieceLineInstance => {
                                pieceLineInstance.instances.push(
                                    pieceLineInstance.geometry.clone().applyMatrix4(object3d.matrix));
                            });
                        }

                        pieceInstancedMeshes.forEach(pieceInstancedMesh => scene.add(pieceInstancedMesh));
                        pieceLineInstances.forEach(pieceLineInstance =>
                            scene.add(new THREE.LineSegments(
                                mergeGeometries(pieceLineInstance.instances, false), pieceLineInstance.material))
                        );
                    }

                    loadPendingPartNumbers.delete(partNumber);
                    if (loadPendingPartNumbers.size == 0) {
                        const totalPieces = Object
                            .values(pieces)
                            .flatMap(piecesEntry => Object
                                .values(piecesEntry)
                                .map(pieceConfigurationsByOpacity => pieceConfigurationsByOpacity.length))
                            .reduce((previous, current) => previous + current, 0);

                        console.log(`Done loading ${totalPieces} pieces at: ${window.performance.now()}`);
                    }
                },
                function(xhr) {/*progress*/},
                function(error) {
                    console.log(`Error loading file: ${partFile}`);
                    console.error(error);
                }
            );
        }
    }
    addPieces();

    if (options.showGui) {
        const gui = new GUI().close();

        gui.add(options, 'upAxis', {
            "Y up (Three.js)": "Y",
            "Z up (3D Printer)": "Z"
        }).name("OBJ Coordinate System");

        const guiDownloadDefaultName = "Download OBJ";
        const guiDownload = gui.add({downloadObj() {
            guiDownload.disable();

            setTimeout(async () => {
                try {
                    const startTime = window.performance.now();
                    const data = await pieceInstances.getObjData(options.upAxis === "Y", async (screenName) => {
                        guiDownload.name(`Working... ${screenName}`);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    });
                    const elapseTime = window.performance.now() - startTime;
                    console.log(`Get obj data took: ${elapseTime / 1000} ms`);
                    downloadBlob(new Blob([data], {type: 'application/gzip'}), "hyrule.tar.gz");
                } catch (error) {
                    console.error("Download failed:", error);
                } finally {
                    guiDownload.name(guiDownloadDefaultName);
                    guiDownload.enable();
                }
            }, 10);
        }}, "downloadObj").name(guiDownloadDefaultName);

        gui.add({screenshot() {
            renderer.render(scene, camera, null, false);
            renderer.domElement.toBlob((blob) => {
                downloadBlob(blob, "hyrule.png");
            });
        }}, "screenshot").name("Screenshot");

        const guiCameraPosition = gui.addFolder('Camera Position');
        guiCameraPosition.add(camera.position, 'x', -4000, 4000).step(0.01).listen();
        guiCameraPosition.add(camera.position, 'y', -4000, 4000).step(0.01).listen();
        guiCameraPosition.add(camera.position, 'z', -4000, 4000).step(0.01).listen();
        const guiCameraTarget = gui.addFolder('Camera Target');
        guiCameraTarget.add(controls.target, 'x', -4000, 4000).step(0.01).listen();
        guiCameraTarget.add(controls.target, 'y', -4000, 4000).step(0.01).listen();
        guiCameraTarget.add(controls.target, 'z', -4000, 4000).step(0.01).listen();

        const guiCameraUrlDefaultName = "Copy Camera URL to clipboard";
        const guiCameraUrl = gui.add({copyCameraURL() {
            const urlParams = new URLSearchParams(window.location.search);

            for (const [key, value] of [
                ["cameraPositionX", camera.position.x.toFixed(2)],
                ["cameraPositionY", camera.position.y.toFixed(2)],
                ["cameraPositionZ", camera.position.z.toFixed(2)],
                ["cameraTargetX", controls.target.x.toFixed(2)],
                ["cameraTargetY", controls.target.y.toFixed(2)],
                ["cameraTargetZ", controls.target.z.toFixed(2)],
            ]) {
                urlParams.delete(key);
                urlParams.set(key, value);
            }

            const cameraUrl = `${window.location.origin}${window.location.pathname}?${urlParams}`;
            console.log(`Camera URL: ${cameraUrl}`);

            navigator.clipboard.writeText(cameraUrl).then(() => {
                guiCameraUrl.name("Copied!");
                setTimeout(() => guiCameraUrl.name(guiCameraUrlDefaultName), 1000);
            });
        }}, "copyCameraURL").name(guiCameraUrlDefaultName);

        gui.add(options, 'palette', {nes: "nes", 'ldraw(lego)' : 'ldraw'})
            .name('Color Palette')
            .onChange(value => pieceInstances.changePalette(value));

        gui.add(options, 'clearColor', {
            'nes 1D Black': 0x000000,
            'nes 2D Dark Gray': 0x787878,
            'nes 3D Gray':  0xC4C4C4,

            'nes 22 Lavender': 0x5C94FC,
            'nes 31 Pale Blue': 0xA8E4FC,
            'nes 3C Pale Grey-Blue': 0x9CFCF0,

            'ldraw 9 Light Blue': 0x97CBD9,
            'ldraw 323 Light Aqua': 0xD3F2EA,

            'Light Gray': 0xDDDDDD,
            'Very Pale Grey-Blue': 0xDDEDEE,
            'Lego Instruction Manual': 0xD4EDFC,
        })
            .name('Clear Color')
            .onChange(value => renderer.setClearColor(value));

        gui.add({toggleLines() {
            scene.traverse(item => {
                if (item.isLine) {
                    item.visible = !item.visible;
                }
            });
        }}, "toggleLines").name("Toggle Lines");

        const guiMaterial = gui.addFolder('Materials');
        guiMaterial.add(options, 'roughness', 0, 1).step(0.01).onChange(value => {
            scene.traverse(item => {
                if (item.isMesh && item.material.isMeshStandardMaterial) {
                    item.material.roughness = value;
                }
            });
        });
        guiMaterial.add(options, 'polygonOffsetFactor', 0, 1).step(0.01).onChange(value => {
            scene.traverse(item => {
                if (item.isMesh && item.material.isMeshStandardMaterial) {
                    item.material.polygonOffset = value !== 0;
                    item.material.polygonOffsetFactor = value;
                }
            });
        });
    }

    function downloadBlob(blob, filename) {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
    }

</script>
</body>
</html>
